grammar aom.scripting.xs.XS
	hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate xs "http://aom.eso.com/xs"

 /*
  * NOT supported by XS
  * - power a^n
  * - ternary b ? x : y;
  * - prefix: ++i
  * - inline pre/postfix: a + x++
  * - unary minus: -x 
  * - XOR (^)
  * - negation (!)
  * - long, double?
  * - bitwise and/or
  * - +=, -=, ...
  * 
  * other notes:
  *  - operator precedence is weird
  *  - only three scopes: global, file, local; file scope is only used for non-exported global variables
  *  - return() requires parentheses (except if not returning anything), and is optional
  *  - function arguments require default values
  *  - vector() only works for constant arguments
  *  - functions must be defined before they are used like in C, forward declarations are done with 'mutable <header> {}'
  *  - switch cases don't require a 'break'
  */

Program
	: declarations += Declaration*
	;
	
Declaration
	: GlobalVarDeclaration
	| FunDeclaration
	| IncludeStatement
	| RuleDeclaration
	;

IncludeStatement
	: 'include' filePath=STRING ';' // paths are relative to main directory (e.g. ai2 or trigger2), not to current directory
	;
	
VarDeclaration
	: type=VarTypeSpecifier name=ID '=' value=Expression //no semicolon to enable reuse
	;
	
GlobalVarDeclaration returns VarDeclaration
	: {GlobalVarDeclaration} modifier=VarModifier type=VarTypeSpecifier name=ID '=' value=LiteralOrVar ';'
	;
	
VarModifier
	: {VarModifier} (const?='const'? & extern?='extern'?)
	;
	
ParameterDeclaration returns VarDeclaration
	: type=VarTypeSpecifier name=ID '=' value=LiteralOrVar
	;
	
ForVarDeclaration returns VarDeclaration
	: name=ID '=' value=Expression //type='int'
	;

FunDeclaration
	: modifier=FunModifier type=FunTypeSpecifier name=ID '(' paramlist=Params? ')' statements=CompoundStatement
	;
	
FunTypeSpecifier
	: VoidType
	| VarTypeSpecifier
	;
	
Params
	: {Params} 'void'
	| params += ParameterDeclaration (',' params += ParameterDeclaration)*
	;
	
RuleDeclaration
	: 'rule' name=ID (
			(active?= 'active'|'inactive')
			& runImmediately?='runImmediately'?
			& highFrequency?='highFrequency'? 
			& ('group' group=ID)? 
			& ('minInterval' minInterval=INT)? 
			& ('maxInterval' maxInterval=INT)?
		)
		statements=CompoundStatement
	;

FunModifier
	: {FunModifier} mutable?='mutable'?
	;

VarTypeSpecifier
	: IntType
	| FloatType
	| BoolType
	| VectorType
	| StringType
	;
	
CompoundStatement
	: {CompoundStatement} '{' contents += (VarDeclarationOrStatement)* '}'
	;
	
VarDeclarationOrStatement
	: VarDeclaration ';'
	| Statement
	;
		
Statement
	: ExpressionStatement
    | PostfixStatement
    | CompoundStatement
	| IfElseStatement
	| WhileStatement
	| ForStatement
	| SwitchStatement
	| ReturnStatement
	| ContinueStatement //TODO add some restrictions (inside loop)
	| BreakStatement 
	;
	
ExpressionStatement //typically 1 line, ends in semicolon
	: expression = Expression ';'
	;
	
PostfixStatement
	: var=[VarDeclaration] op=PostFixOp ';'
	;
	
IfElseStatement
	: 'if' '(' condition = Expression ')' thenStatement = Statement (=>'else' elseStatement=Statement)?
	;
	
WhileStatement
	: 'while' '(' condition = Expression ')' statement = Statement
	;
	
ForStatement
	: 'for' '(' var=ForVarDeclaration ';' op = RelOp expression = Expression ')' statement = Statement
	;
	
SwitchStatement
	: 'switch' '(' var=[VarDeclaration] ')' '{' cases+=SwitchCase* default=SwitchDefault? '}'
	;
	
SwitchCase // TODO check if strings, floats, ... allowed
	: 'case' '(' var=LiteralNumOrVar ')' ':' statement=Statement
	;
	
SwitchDefault
	: 'default' ':' statement=Statement
	;

ReturnStatement
	: {ReturnStatement} 'return' ('(' expression = Expression ')')? ';'
	;
	
ContinueStatement
	: {ContinueStatement} 'continue' ';'
	;
	
BreakStatement
	: {BreakStatement} 'break' ';'
	;

PostFixOp
	: '++'
	| '--'
	;

Expression
	: {AssignmentExpression} (var = Var '=' expression = Expression)
	| expression = SimpleExpression
	;
	
Var
	: declaration=[VarDeclaration]
	;
	
SimpleExpression returns Expression
	: AndExpression ({Or.left=current} op='||' right=AndExpression)*
	;
	
AndExpression returns Expression
	: EqualsExpression ({And.left=current} op='&&' right=EqualsExpression)*
	;

EqualsExpression returns Expression
	: ComparisonExpression ({Equals.left=current} op=EqOp right=ComparisonExpression)?
	;
	
EqOp
	: '=='
	| '!='
	;

ComparisonExpression returns Expression
	: AdditiveExpression ({Comparison.left=current} op=RelOp right=AdditiveExpression)?
	;

RelOp
	: '<=' 
	| '<' 
	| '>' 
	| '>=' 
	;

AdditiveExpression returns Expression
	: MultiplicativeExpression ({Term.left=current} op=AddOp right=MultiplicativeExpression)*
	;

AddOp
	: '+' 
	| '-'
	;
	
MultiplicativeExpression returns Expression
	: Atom ({Factor.left=current} op=MulOp right=Atom)*
	;
	
MulOp
	: '*'
	| '/'
	| '%' //modulo has same order of operation as multiplication
	;
	
Atom returns Expression
	: {PrimaryExpression} ('(' expression = Expression ')')
	| Call
	| LiteralOrVar
	;

LiteralOrVar
	: Var
	| Literal
	;

Literal
	: LiteralNum
	| {LiteralVector} value=Vector
	| {LiteralString} value=STRING //TODO concatenation != addition
	;

LiteralNum
	: {LiteralInt} value=SignedInt
	| {LiteralFloat} value=SignedFloat
	| {LiteralBool} value=Bool // booleans are treated like ints
	;
	
LiteralNumOrVar
	: LiteralNum
	| Var
	;
	
Call
	: function=[FunDeclaration] '(' args=Arguments? ')'
	;
	
Arguments
	: expressions += Expression (',' expressions += Expression)* //TODO link with params
	;

IntType
	: {IntType} 'int'
	;
	
FloatType
	: {FloatType} 'float'
	;
	
BoolType
	: {BoolType} 'bool'
	;
	
VectorType
	: {VectorType} 'vector'
	;
	
StringType
	: {StringType} 'string'
	;
	
VoidType
	: {VoidType} 'void'
	;
	
Sign
	: '-'
//  | '+' //not allowed!
	;
	
SignedInt returns ecore::EInt
	: Sign? INT // TODO check that this is <= 9 digits
	;
	
SignedFloat returns ecore::EFloat
	: Sign? INT '.' INT
	;
	
Bool returns ecore::EBoolean
	: 'true'
	| 'false'
	;
	
Vector
	: 'vector' '(' x=LiteralNumOrVar ',' y=LiteralNumOrVar ',' z=LiteralNumOrVar ')' //only literals or constants, else use xsVectorSet
	;
	
	
terminal ID: 
    ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
 
terminal INT returns ecore::EInt: 
    ('0'..'9')+;
 
terminal STRING: 
    '"' ( '\\"' | !('"'|'\n') )* '"';
    // XS strings use invalid escaping: the backslash only escapes double quotes and nothing else,
    // i.e. '\"' is '"', but '\\' is not '\', it's either '\\' or '\"' depending on where in the string it is.
 
terminal ML_COMMENT: 
    '/*' -> '*/';
 
terminal SL_COMMENT: 
    '//' !('\n'|'\r')* ('\r'? '\n')?;
 
terminal WS: 
    (' '|'\t'|'\r'|'\n')+;
 
terminal ANY_OTHER: 
    .;