/*
 * generated by Xtext
 */
package aom.scripting.xs.serializer;

import aom.scripting.xs.services.XSGrammarAccess;
import aom.scripting.xs.xs.And;
import aom.scripting.xs.xs.Arguments;
import aom.scripting.xs.xs.AssignmentExpression;
import aom.scripting.xs.xs.BoolType;
import aom.scripting.xs.xs.BreakStatement;
import aom.scripting.xs.xs.Call;
import aom.scripting.xs.xs.Comparison;
import aom.scripting.xs.xs.CompoundStatement;
import aom.scripting.xs.xs.ContinueStatement;
import aom.scripting.xs.xs.Equals;
import aom.scripting.xs.xs.Expression;
import aom.scripting.xs.xs.ExpressionStatement;
import aom.scripting.xs.xs.Factor;
import aom.scripting.xs.xs.FloatType;
import aom.scripting.xs.xs.ForStatement;
import aom.scripting.xs.xs.FunDeclaration;
import aom.scripting.xs.xs.FunModifier;
import aom.scripting.xs.xs.GlobalVarDeclaration;
import aom.scripting.xs.xs.IfElseStatement;
import aom.scripting.xs.xs.IncludeStatement;
import aom.scripting.xs.xs.IntType;
import aom.scripting.xs.xs.LiteralBool;
import aom.scripting.xs.xs.LiteralFloat;
import aom.scripting.xs.xs.LiteralInt;
import aom.scripting.xs.xs.LiteralString;
import aom.scripting.xs.xs.LiteralVector;
import aom.scripting.xs.xs.Or;
import aom.scripting.xs.xs.Params;
import aom.scripting.xs.xs.PostfixStatement;
import aom.scripting.xs.xs.PrimaryExpression;
import aom.scripting.xs.xs.Program;
import aom.scripting.xs.xs.ReturnStatement;
import aom.scripting.xs.xs.RuleDeclaration;
import aom.scripting.xs.xs.StringType;
import aom.scripting.xs.xs.SwitchCase;
import aom.scripting.xs.xs.SwitchDefault;
import aom.scripting.xs.xs.SwitchStatement;
import aom.scripting.xs.xs.Term;
import aom.scripting.xs.xs.Var;
import aom.scripting.xs.xs.VarDeclaration;
import aom.scripting.xs.xs.VarModifier;
import aom.scripting.xs.xs.Vector;
import aom.scripting.xs.xs.VectorType;
import aom.scripting.xs.xs.VoidType;
import aom.scripting.xs.xs.WhileStatement;
import aom.scripting.xs.xs.XsPackage;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XsPackage.AND:
				sequence_AndExpression(context, (And) semanticObject); 
				return; 
			case XsPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case XsPackage.ASSIGNMENT_EXPRESSION:
				sequence_Expression(context, (AssignmentExpression) semanticObject); 
				return; 
			case XsPackage.BOOL_TYPE:
				sequence_BoolType(context, (BoolType) semanticObject); 
				return; 
			case XsPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case XsPackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case XsPackage.COMPARISON:
				sequence_ComparisonExpression(context, (Comparison) semanticObject); 
				return; 
			case XsPackage.COMPOUND_STATEMENT:
				sequence_CompoundStatement(context, (CompoundStatement) semanticObject); 
				return; 
			case XsPackage.CONTINUE_STATEMENT:
				sequence_ContinueStatement(context, (ContinueStatement) semanticObject); 
				return; 
			case XsPackage.EQUALS:
				sequence_EqualsExpression(context, (Equals) semanticObject); 
				return; 
			case XsPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case XsPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case XsPackage.FACTOR:
				sequence_MultiplicativeExpression(context, (Factor) semanticObject); 
				return; 
			case XsPackage.FLOAT_TYPE:
				sequence_FloatType(context, (FloatType) semanticObject); 
				return; 
			case XsPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case XsPackage.FUN_DECLARATION:
				sequence_FunDeclaration(context, (FunDeclaration) semanticObject); 
				return; 
			case XsPackage.FUN_MODIFIER:
				sequence_FunModifier(context, (FunModifier) semanticObject); 
				return; 
			case XsPackage.GLOBAL_VAR_DECLARATION:
				sequence_GlobalVarDeclaration(context, (GlobalVarDeclaration) semanticObject); 
				return; 
			case XsPackage.IF_ELSE_STATEMENT:
				sequence_IfElseStatement(context, (IfElseStatement) semanticObject); 
				return; 
			case XsPackage.INCLUDE_STATEMENT:
				sequence_IncludeStatement(context, (IncludeStatement) semanticObject); 
				return; 
			case XsPackage.INT_TYPE:
				sequence_IntType(context, (IntType) semanticObject); 
				return; 
			case XsPackage.LITERAL_BOOL:
				sequence_LiteralNum(context, (LiteralBool) semanticObject); 
				return; 
			case XsPackage.LITERAL_FLOAT:
				sequence_LiteralNum(context, (LiteralFloat) semanticObject); 
				return; 
			case XsPackage.LITERAL_INT:
				sequence_LiteralNum(context, (LiteralInt) semanticObject); 
				return; 
			case XsPackage.LITERAL_STRING:
				sequence_Literal(context, (LiteralString) semanticObject); 
				return; 
			case XsPackage.LITERAL_VECTOR:
				sequence_Literal(context, (LiteralVector) semanticObject); 
				return; 
			case XsPackage.OR:
				sequence_SimpleExpression(context, (Or) semanticObject); 
				return; 
			case XsPackage.PARAMS:
				sequence_Params(context, (Params) semanticObject); 
				return; 
			case XsPackage.POSTFIX_STATEMENT:
				sequence_PostfixStatement(context, (PostfixStatement) semanticObject); 
				return; 
			case XsPackage.PRIMARY_EXPRESSION:
				sequence_Atom(context, (PrimaryExpression) semanticObject); 
				return; 
			case XsPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case XsPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case XsPackage.RULE_DECLARATION:
				sequence_RuleDeclaration(context, (RuleDeclaration) semanticObject); 
				return; 
			case XsPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case XsPackage.SWITCH_CASE:
				sequence_SwitchCase(context, (SwitchCase) semanticObject); 
				return; 
			case XsPackage.SWITCH_DEFAULT:
				sequence_SwitchDefault(context, (SwitchDefault) semanticObject); 
				return; 
			case XsPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case XsPackage.TERM:
				sequence_AdditiveExpression(context, (Term) semanticObject); 
				return; 
			case XsPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case XsPackage.VAR_DECLARATION:
				if (rule == grammarAccess.getForVarDeclarationRule()) {
					sequence_ForVarDeclaration(context, (VarDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterDeclarationRule()) {
					sequence_ParameterDeclaration(context, (VarDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarDeclarationRule()
						|| rule == grammarAccess.getVarDeclarationOrStatementRule()) {
					sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
					return; 
				}
				else break;
			case XsPackage.VAR_MODIFIER:
				sequence_VarModifier(context, (VarModifier) semanticObject); 
				return; 
			case XsPackage.VECTOR:
				sequence_Vector(context, (Vector) semanticObject); 
				return; 
			case XsPackage.VECTOR_TYPE:
				sequence_VectorType(context, (VectorType) semanticObject); 
				return; 
			case XsPackage.VOID_TYPE:
				sequence_VoidType(context, (VoidType) semanticObject); 
				return; 
			case XsPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Term
	 *     SimpleExpression.Or_1_0 returns Term
	 *     AndExpression returns Term
	 *     AndExpression.And_1_0 returns Term
	 *     EqualsExpression returns Term
	 *     EqualsExpression.Equals_1_0 returns Term
	 *     ComparisonExpression returns Term
	 *     ComparisonExpression.Comparison_1_0 returns Term
	 *     AdditiveExpression returns Term
	 *     AdditiveExpression.Term_1_0 returns Term
	 *
	 * Constraint:
	 *     (left=AdditiveExpression_Term_1_0 op=AddOp right=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, Term semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.TERM__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.TERM__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getOpAddOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getRightMultiplicativeExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns And
	 *     SimpleExpression.Or_1_0 returns And
	 *     AndExpression returns And
	 *     AndExpression.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=AndExpression_And_1_0 op='&&' right=EqualsExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.AND__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.AND__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOpAmpersandAmpersandKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualsExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns PrimaryExpression
	 *     SimpleExpression.Or_1_0 returns PrimaryExpression
	 *     AndExpression returns PrimaryExpression
	 *     AndExpression.And_1_0 returns PrimaryExpression
	 *     EqualsExpression returns PrimaryExpression
	 *     EqualsExpression.Equals_1_0 returns PrimaryExpression
	 *     ComparisonExpression returns PrimaryExpression
	 *     ComparisonExpression.Comparison_1_0 returns PrimaryExpression
	 *     AdditiveExpression returns PrimaryExpression
	 *     AdditiveExpression.Term_1_0 returns PrimaryExpression
	 *     MultiplicativeExpression returns PrimaryExpression
	 *     MultiplicativeExpression.Factor_1_0 returns PrimaryExpression
	 *     Atom returns PrimaryExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Atom(ISerializationContext context, PrimaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getExpressionExpressionParserRuleCall_0_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunTypeSpecifier returns BoolType
	 *     VarTypeSpecifier returns BoolType
	 *     BoolType returns BoolType
	 *
	 * Constraint:
	 *     {BoolType}
	 */
	protected void sequence_BoolType(ISerializationContext context, BoolType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns BreakStatement
	 *     Statement returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Call
	 *     SimpleExpression.Or_1_0 returns Call
	 *     AndExpression returns Call
	 *     AndExpression.And_1_0 returns Call
	 *     EqualsExpression returns Call
	 *     EqualsExpression.Equals_1_0 returns Call
	 *     ComparisonExpression returns Call
	 *     ComparisonExpression.Comparison_1_0 returns Call
	 *     AdditiveExpression returns Call
	 *     AdditiveExpression.Term_1_0 returns Call
	 *     MultiplicativeExpression returns Call
	 *     MultiplicativeExpression.Factor_1_0 returns Call
	 *     Atom returns Call
	 *     Call returns Call
	 *
	 * Constraint:
	 *     (function=[FunDeclaration|ID] args=Arguments?)
	 */
	protected void sequence_Call(ISerializationContext context, Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Comparison
	 *     SimpleExpression.Or_1_0 returns Comparison
	 *     AndExpression returns Comparison
	 *     AndExpression.And_1_0 returns Comparison
	 *     EqualsExpression returns Comparison
	 *     EqualsExpression.Equals_1_0 returns Comparison
	 *     ComparisonExpression returns Comparison
	 *
	 * Constraint:
	 *     (left=ComparisonExpression_Comparison_1_0 op=RelOp right=AdditiveExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.COMPARISON__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.COMPARISON__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getOpRelOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRightAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompoundStatement returns CompoundStatement
	 *     VarDeclarationOrStatement returns CompoundStatement
	 *     Statement returns CompoundStatement
	 *
	 * Constraint:
	 *     contents+=VarDeclarationOrStatement*
	 */
	protected void sequence_CompoundStatement(ISerializationContext context, CompoundStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns ContinueStatement
	 *     Statement returns ContinueStatement
	 *     ContinueStatement returns ContinueStatement
	 *
	 * Constraint:
	 *     {ContinueStatement}
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, ContinueStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Equals
	 *     SimpleExpression.Or_1_0 returns Equals
	 *     AndExpression returns Equals
	 *     AndExpression.And_1_0 returns Equals
	 *     EqualsExpression returns Equals
	 *
	 * Constraint:
	 *     (left=EqualsExpression_Equals_1_0 op=EqOp right=ComparisonExpression)
	 */
	protected void sequence_EqualsExpression(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EQUALS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EQUALS__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getEqualsLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getOpEqOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getRightComparisonExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns ExpressionStatement
	 *     Statement returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AssignmentExpression
	 *
	 * Constraint:
	 *     (var=Var expression=Expression)
	 */
	protected void sequence_Expression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.ASSIGNMENT_EXPRESSION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.ASSIGNMENT_EXPRESSION__VAR));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getVarVarParserRuleCall_0_1_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionExpressionParserRuleCall_0_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     expression=SimpleExpression
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionSimpleExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunTypeSpecifier returns FloatType
	 *     VarTypeSpecifier returns FloatType
	 *     FloatType returns FloatType
	 *
	 * Constraint:
	 *     {FloatType}
	 */
	protected void sequence_FloatType(ISerializationContext context, FloatType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns ForStatement
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (var=ForVarDeclaration op=RelOp expression=Expression statement=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__VAR));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getVarForVarDeclarationParserRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getForStatementAccess().getOpRelOpParserRuleCall_4_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getForStatementAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getForStatementAccess().getStatementStatementParserRuleCall_7_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForVarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_ForVarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForVarDeclarationAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getForVarDeclarationAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns FunDeclaration
	 *     FunDeclaration returns FunDeclaration
	 *
	 * Constraint:
	 *     (modifier=FunModifier type=FunTypeSpecifier name=ID paramlist=Params? statements=CompoundStatement)
	 */
	protected void sequence_FunDeclaration(ISerializationContext context, FunDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunModifier returns FunModifier
	 *
	 * Constraint:
	 *     mutable?='mutable'?
	 */
	protected void sequence_FunModifier(ISerializationContext context, FunModifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns GlobalVarDeclaration
	 *     GlobalVarDeclaration returns GlobalVarDeclaration
	 *
	 * Constraint:
	 *     (modifier=VarModifier type=VarTypeSpecifier name=ID value=LiteralOrVar)
	 */
	protected void sequence_GlobalVarDeclaration(ISerializationContext context, GlobalVarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.GLOBAL_VAR_DECLARATION__MODIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.GLOBAL_VAR_DECLARATION__MODIFIER));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalVarDeclarationAccess().getModifierVarModifierParserRuleCall_1_0(), semanticObject.getModifier());
		feeder.accept(grammarAccess.getGlobalVarDeclarationAccess().getTypeVarTypeSpecifierParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getGlobalVarDeclarationAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGlobalVarDeclarationAccess().getValueLiteralOrVarParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns IfElseStatement
	 *     Statement returns IfElseStatement
	 *     IfElseStatement returns IfElseStatement
	 *
	 * Constraint:
	 *     (condition=Expression thenStatement=Statement elseStatement=Statement?)
	 */
	protected void sequence_IfElseStatement(ISerializationContext context, IfElseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns IncludeStatement
	 *     IncludeStatement returns IncludeStatement
	 *
	 * Constraint:
	 *     filePath=STRING
	 */
	protected void sequence_IncludeStatement(ISerializationContext context, IncludeStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.INCLUDE_STATEMENT__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.INCLUDE_STATEMENT__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeStatementAccess().getFilePathSTRINGTerminalRuleCall_1_0(), semanticObject.getFilePath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunTypeSpecifier returns IntType
	 *     VarTypeSpecifier returns IntType
	 *     IntType returns IntType
	 *
	 * Constraint:
	 *     {IntType}
	 */
	protected void sequence_IntType(ISerializationContext context, IntType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns LiteralBool
	 *     SimpleExpression.Or_1_0 returns LiteralBool
	 *     AndExpression returns LiteralBool
	 *     AndExpression.And_1_0 returns LiteralBool
	 *     EqualsExpression returns LiteralBool
	 *     EqualsExpression.Equals_1_0 returns LiteralBool
	 *     ComparisonExpression returns LiteralBool
	 *     ComparisonExpression.Comparison_1_0 returns LiteralBool
	 *     AdditiveExpression returns LiteralBool
	 *     AdditiveExpression.Term_1_0 returns LiteralBool
	 *     MultiplicativeExpression returns LiteralBool
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralBool
	 *     Atom returns LiteralBool
	 *     LiteralOrVar returns LiteralBool
	 *     Literal returns LiteralBool
	 *     LiteralNum returns LiteralBool
	 *     LiteralNumOrVar returns LiteralBool
	 *
	 * Constraint:
	 *     value=Bool
	 */
	protected void sequence_LiteralNum(ISerializationContext context, LiteralBool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_BOOL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_BOOL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralNumAccess().getValueBoolParserRuleCall_2_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns LiteralFloat
	 *     SimpleExpression.Or_1_0 returns LiteralFloat
	 *     AndExpression returns LiteralFloat
	 *     AndExpression.And_1_0 returns LiteralFloat
	 *     EqualsExpression returns LiteralFloat
	 *     EqualsExpression.Equals_1_0 returns LiteralFloat
	 *     ComparisonExpression returns LiteralFloat
	 *     ComparisonExpression.Comparison_1_0 returns LiteralFloat
	 *     AdditiveExpression returns LiteralFloat
	 *     AdditiveExpression.Term_1_0 returns LiteralFloat
	 *     MultiplicativeExpression returns LiteralFloat
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralFloat
	 *     Atom returns LiteralFloat
	 *     LiteralOrVar returns LiteralFloat
	 *     Literal returns LiteralFloat
	 *     LiteralNum returns LiteralFloat
	 *     LiteralNumOrVar returns LiteralFloat
	 *
	 * Constraint:
	 *     value=SignedFloat
	 */
	protected void sequence_LiteralNum(ISerializationContext context, LiteralFloat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralNumAccess().getValueSignedFloatParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns LiteralInt
	 *     SimpleExpression.Or_1_0 returns LiteralInt
	 *     AndExpression returns LiteralInt
	 *     AndExpression.And_1_0 returns LiteralInt
	 *     EqualsExpression returns LiteralInt
	 *     EqualsExpression.Equals_1_0 returns LiteralInt
	 *     ComparisonExpression returns LiteralInt
	 *     ComparisonExpression.Comparison_1_0 returns LiteralInt
	 *     AdditiveExpression returns LiteralInt
	 *     AdditiveExpression.Term_1_0 returns LiteralInt
	 *     MultiplicativeExpression returns LiteralInt
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralInt
	 *     Atom returns LiteralInt
	 *     LiteralOrVar returns LiteralInt
	 *     Literal returns LiteralInt
	 *     LiteralNum returns LiteralInt
	 *     LiteralNumOrVar returns LiteralInt
	 *
	 * Constraint:
	 *     value=SignedInt
	 */
	protected void sequence_LiteralNum(ISerializationContext context, LiteralInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralNumAccess().getValueSignedIntParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns LiteralString
	 *     SimpleExpression.Or_1_0 returns LiteralString
	 *     AndExpression returns LiteralString
	 *     AndExpression.And_1_0 returns LiteralString
	 *     EqualsExpression returns LiteralString
	 *     EqualsExpression.Equals_1_0 returns LiteralString
	 *     ComparisonExpression returns LiteralString
	 *     ComparisonExpression.Comparison_1_0 returns LiteralString
	 *     AdditiveExpression returns LiteralString
	 *     AdditiveExpression.Term_1_0 returns LiteralString
	 *     MultiplicativeExpression returns LiteralString
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralString
	 *     Atom returns LiteralString
	 *     LiteralOrVar returns LiteralString
	 *     Literal returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Literal(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns LiteralVector
	 *     SimpleExpression.Or_1_0 returns LiteralVector
	 *     AndExpression returns LiteralVector
	 *     AndExpression.And_1_0 returns LiteralVector
	 *     EqualsExpression returns LiteralVector
	 *     EqualsExpression.Equals_1_0 returns LiteralVector
	 *     ComparisonExpression returns LiteralVector
	 *     ComparisonExpression.Comparison_1_0 returns LiteralVector
	 *     AdditiveExpression returns LiteralVector
	 *     AdditiveExpression.Term_1_0 returns LiteralVector
	 *     MultiplicativeExpression returns LiteralVector
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralVector
	 *     Atom returns LiteralVector
	 *     LiteralOrVar returns LiteralVector
	 *     Literal returns LiteralVector
	 *
	 * Constraint:
	 *     value=Vector
	 */
	protected void sequence_Literal(ISerializationContext context, LiteralVector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_VECTOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_VECTOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValueVectorParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Factor
	 *     SimpleExpression.Or_1_0 returns Factor
	 *     AndExpression returns Factor
	 *     AndExpression.And_1_0 returns Factor
	 *     EqualsExpression returns Factor
	 *     EqualsExpression.Equals_1_0 returns Factor
	 *     ComparisonExpression returns Factor
	 *     ComparisonExpression.Comparison_1_0 returns Factor
	 *     AdditiveExpression returns Factor
	 *     AdditiveExpression.Term_1_0 returns Factor
	 *     MultiplicativeExpression returns Factor
	 *     MultiplicativeExpression.Factor_1_0 returns Factor
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_Factor_1_0 op=MulOp right=Atom)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, Factor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FACTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FACTOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FACTOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FACTOR__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FACTOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FACTOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getFactorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getOpMulOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightAtomParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (type=VarTypeSpecifier name=ID value=LiteralOrVar)
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getTypeVarTypeSpecifierParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getValueLiteralOrVarParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Params returns Params
	 *
	 * Constraint:
	 *     (params+=ParameterDeclaration params+=ParameterDeclaration*)?
	 */
	protected void sequence_Params(ISerializationContext context, Params semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns PostfixStatement
	 *     Statement returns PostfixStatement
	 *     PostfixStatement returns PostfixStatement
	 *
	 * Constraint:
	 *     (var=[VarDeclaration|ID] op=PostFixOp)
	 */
	protected void sequence_PostfixStatement(ISerializationContext context, PostfixStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__VAR));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixStatementAccess().getVarVarDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.getVar());
		feeder.accept(grammarAccess.getPostfixStatementAccess().getOpPostFixOpParserRuleCall_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     declarations+=Declaration+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns ReturnStatement
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns RuleDeclaration
	 *     RuleDeclaration returns RuleDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             active?='active' | 
	 *             runImmediately?='runImmediately' | 
	 *             highFrequency?='highFrequency' | 
	 *             group=ID | 
	 *             minInterval=INT | 
	 *             maxInterval=INT
	 *         )* 
	 *         statements=CompoundStatement
	 *     )
	 */
	protected void sequence_RuleDeclaration(ISerializationContext context, RuleDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Or
	 *     SimpleExpression.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=SimpleExpression_Or_1_0 op='||' right=AndExpression)
	 */
	protected void sequence_SimpleExpression(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.OR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.OR__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getOpVerticalLineVerticalLineKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunTypeSpecifier returns StringType
	 *     VarTypeSpecifier returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchCase returns SwitchCase
	 *
	 * Constraint:
	 *     (var=LiteralNumOrVar statement=Statement)
	 */
	protected void sequence_SwitchCase(ISerializationContext context, SwitchCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.SWITCH_CASE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.SWITCH_CASE__VAR));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.SWITCH_CASE__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.SWITCH_CASE__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchCaseAccess().getVarLiteralNumOrVarParserRuleCall_1_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getSwitchCaseAccess().getStatementStatementParserRuleCall_3_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchDefault returns SwitchDefault
	 *
	 * Constraint:
	 *     statement=Statement
	 */
	protected void sequence_SwitchDefault(ISerializationContext context, SwitchDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.SWITCH_DEFAULT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.SWITCH_DEFAULT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchDefaultAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns SwitchStatement
	 *     Statement returns SwitchStatement
	 *     SwitchStatement returns SwitchStatement
	 *
	 * Constraint:
	 *     (var=[VarDeclaration|ID] cases+=SwitchCase* default=SwitchDefault?)
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns VarDeclaration
	 *     VarDeclarationOrStatement returns VarDeclaration
	 *
	 * Constraint:
	 *     (type=VarTypeSpecifier name=ID value=Expression)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclarationAccess().getTypeVarTypeSpecifierParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarDeclarationAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarModifier returns VarModifier
	 *
	 * Constraint:
	 *     (const?='const' | extern?='extern')*
	 */
	protected void sequence_VarModifier(ISerializationContext context, VarModifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var returns Var
	 *     SimpleExpression returns Var
	 *     SimpleExpression.Or_1_0 returns Var
	 *     AndExpression returns Var
	 *     AndExpression.And_1_0 returns Var
	 *     EqualsExpression returns Var
	 *     EqualsExpression.Equals_1_0 returns Var
	 *     ComparisonExpression returns Var
	 *     ComparisonExpression.Comparison_1_0 returns Var
	 *     AdditiveExpression returns Var
	 *     AdditiveExpression.Term_1_0 returns Var
	 *     MultiplicativeExpression returns Var
	 *     MultiplicativeExpression.Factor_1_0 returns Var
	 *     Atom returns Var
	 *     LiteralOrVar returns Var
	 *     LiteralNumOrVar returns Var
	 *
	 * Constraint:
	 *     declaration=[VarDeclaration|ID]
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR__DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getDeclarationVarDeclarationIDTerminalRuleCall_0_1(), semanticObject.getDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunTypeSpecifier returns VectorType
	 *     VarTypeSpecifier returns VectorType
	 *     VectorType returns VectorType
	 *
	 * Constraint:
	 *     {VectorType}
	 */
	protected void sequence_VectorType(ISerializationContext context, VectorType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Vector returns Vector
	 *
	 * Constraint:
	 *     (x=LiteralNumOrVar y=LiteralNumOrVar z=LiteralNumOrVar)
	 */
	protected void sequence_Vector(ISerializationContext context, Vector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VECTOR__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VECTOR__X));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VECTOR__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VECTOR__Y));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VECTOR__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VECTOR__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVectorAccess().getXLiteralNumOrVarParserRuleCall_2_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getVectorAccess().getYLiteralNumOrVarParserRuleCall_4_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getVectorAccess().getZLiteralNumOrVarParserRuleCall_6_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunTypeSpecifier returns VoidType
	 *     VoidType returns VoidType
	 *
	 * Constraint:
	 *     {VoidType}
	 */
	protected void sequence_VoidType(ISerializationContext context, VoidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns WhileStatement
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression statement=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.WHILE_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.WHILE_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
}
